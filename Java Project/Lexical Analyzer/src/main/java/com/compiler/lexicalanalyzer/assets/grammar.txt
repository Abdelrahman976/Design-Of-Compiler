############################## Notice ##############################
# Put each rule on a single line.
# Use "→" to separate rule sides.
# Use "ㅣ" to separate productions.
# Use "epsilon" to indicate empty string.
# First symbol will be start symbol.
# Comments like this are ignored.
####################################################################

############################## Example #############################
program → declaration_list
declaration_list → declaration declaration_list ㅣ epsilon

declaration → type_specifier var_declaration ㅣ fun_declaration
var_declaration → Identifier var_declaration' var_declaration_list
var_declaration' →  [ square_brackets ] array_value ㅣ = assign_rhs ㅣ epsilon

assign_rhs → expression ㅣ Identifier ( args ) semi
###---### SOLVE AMBIGUITY HERE FOR IDENTIFIER

var_declaration_list → , Identifier var_declaration' var_declaration_list ㅣ ;
square_brackets → Integer ㅣ Identifier
array_value →  = { value_list } ㅣ = value
value_list → value value_list'
value_list' → , value value_list' ㅣ epsilon
value → String_Literal ㅣ Char_Literal ㅣ Integer ㅣ Float ㅣ Long_Long ㅣ Long ㅣ Hexadecimal ㅣ Octal ㅣ Binary

type_specifier → char ㅣ signed type ㅣ unsigned type ㅣ short ShortInt ㅣ int ㅣ long LongType ㅣ float ㅣ double ㅣ void
type → char ㅣ short ShortInt ㅣ int ㅣ long LongType ㅣ epsilon
ShortInt → int ㅣ epsilon
LongType → long LongType2 ㅣ double ㅣ int ㅣ epsilon
LongType2 → int ㅣ epsilon

fun_declaration → type_specifier Identifier ( params ) compound_stmt
params → param_list ㅣ epsilon
param_list → param param_list'
param_list' → , param param_list' ㅣ epsilon
param → type_specifier Identifier param'
param' → [ ] 2DAㅣ epsilon
2DA → [ square_brackets ] ㅣ epsilon

statement → expression_stmt ㅣ compound_stmt ㅣ selection_stmt ㅣ iteration_stmt ㅣ jump_stmt

# ------------------------

# COMPOUND STATEMENTS

compound_stmt → { internal_declarations }

internal_declarations → local_declarations statement_list internal_declarations ㅣ epsilon

local_declarations → type_specifier var_declaration local_declarations ㅣ epsilon

statement_list → statement statement_list'

statement_list' → statement statement_list' ㅣ epsilon

# ------------------------

# SELECTION STATEMENTS

selection_stmt → if ( expression ) expression_stmt else_part

expression_stmt → compound_stmt ㅣ single_stmt

#block_stmt → { statement_list }

single_stmt → expression ㅣ type_specifier var_declaration

else_part → else expression_stmt ㅣ epsilon

# ------------------------

# ITERATIONS STATEMENTS

iteration_stmt → while ( expression ) expression_stmt ㅣ do compound_stmt while ( expression ) ; ㅣ for forStatement expression_stmt

forStatement → ( forInitialization ; forCondition ; forIncrement )

forInitialization → type_specifier Identifier = value ㅣ epsilon

forCondition → expression ㅣ epsilon

forIncrement → expression ㅣ epsilon

# ------------------------

# JUMP STATEMENTS

jump_stmt → break ; ㅣ continue ; ㅣ return_stmt ㅣ goto_stmt

return_stmt → return return_stmt'

return_stmt' → ; ㅣ expression ;

goto_stmt → goto Identifier ;

# ------------------------

# EXPRESSION STATEMENTS
expression → logical_or_exp

logical_or_exp → logical_and_exp logical_or_exp'
logical_or_exp' → || logical_and_exp logical_or_exp' ㅣ epsilon

logical_and_exp → equality_exp logical_and_exp'
logical_and_exp' → && equality_exp logical_and_exp' ㅣ epsilon

equality_exp → relational_exp equality_exp'
equality_exp' → == relational_exp equality_exp' ㅣ != relational_exp equality_exp' ㅣ epsilon

relational_exp → additive_exp relational_exp'
relational_exp' → < additive_exp relational_exp' ㅣ <= additive_exp relational_exp' ㅣ > additive_exp relational_exp' ㅣ >= additive_exp relational_exp' ㅣ epsilon


additive_exp → term additive_exp'
additive_exp' → + term additive_exp' ㅣ - term additive_exp' ㅣ epsilon
term → factor term'

term' → * factor term' ㅣ / factor term' ㅣ epsilon

factor → ( expression ) ㅣ value ㅣ ++ Identifier factor' ㅣ -- Identifier factor' ㅣ Identifier factor'
factor' → var_assignment ㅣ ++ ㅣ -- ㅣ ( args ) ;
semi →  ; ㅣ epsilon
inc_dec → ++ ㅣ -- ㅣ epsilon


var_assignment → array_brackets RHS

RHS → = expression_list  ㅣ += expression_list  ㅣ -= expression_list  ㅣ *= expression_list  ㅣ /= expression_list  ㅣ inc_dec  ㅣ epsilon
expression_list → expression expression_list'
expression_list' → , expression expression_list' ㅣ ;
array_brackets → [ square_brackets ] 2DAㅣ epsilon
# ------------------------

#func_call → Identifier ( args ) ;

args → arg_list ㅣ epsilon
arg_list → arg_value arg_list'
arg_list' → , arg_value arg_list' ㅣ epsilon
arg_value → value ㅣ Identifier func_call2
func_call2 → ( args ) ㅣ epsilon
